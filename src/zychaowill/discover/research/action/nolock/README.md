#### 有助于提高“锁”性能的几点建议：
“锁”的竞争必然会导致程序的整体性能下降。为了将这种副作用降到最低，有一些关于使用锁的建议：

- 减小锁持有时间
只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量。
```Java
public void syncMethod() {
	otherCode();
	synchronized (this) {
		mutexMethod();
	}
}
```

- 减小锁粒度 ConcurrentHashMap的put & take方法

- 读写分离锁来替换独占锁

- 锁分离

- 锁粗化

性能优化就是根据运行时的真实情况对各个资源点进行权衡这种的过程。锁粗化的思想和减少锁持有时间是相反的，但在不同的场合，它们的效果并不相同。所以需要根据实际情况，进行权衡。

#### Java虚拟机对锁优化所做的努力

- 锁偏向
```Java
-XX:+UseBiasedLocking
```

- 轻量级锁
<br/>轻量级锁的操作也很轻便，它只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果县城获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁。

- 自旋锁
<br/>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会再做最后的努力——自旋锁。系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此，虚拟机会让当前线程做几个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能获得锁，才会真实地将线程在操作系统层面挂起。

- 锁消除
<br/>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。（Vector）<br/>
锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。<br/>
逃逸分析必须在-server模式下进行，可以使用-XX:+DoEscapeAnalysis参数打开逃逸分析。使用-XX:+EliminateLocks参数可以打开锁消除。