除了用于线程同步、确保线程安全外，synchronized还可以保证线程间的可见性和有序性。<br/>
从可见性的角度上讲，synchronized可以完全替代volatile的功能，只是使用上没有那么方便。<br/>
就有序性而言，由于synchronized限制每次只有一个线程可以访问同步块，因此，无论同步块内的代码如何被乱序执行，只要保证串行语义一致，那么执行结果总是一样的。而其他访问线程，又必须在获得锁后方能进入代码块读取数据，因此，它们看到的最终结果并不取决于代码的执行过程，从而有序性问题得到了解决（换言之，被synchronized限制的多个线程是串行执行的）。<br/>
<br/>
<br/>
volatile对于保证操作的原子性是有非常大的帮助的。但是需要注意的是，volatile并不能代替锁，它也无法保证一些复合操作的原子性。<br/>
Please refer to CannotGuranterrAtomicityOperation class.<br/>
<br/>
volatile也能保证数据的可见性和有序性。<br/>
<br/>
<br/>
关键字synchronized的作用是实现线程间的同步。它的工作是对同步的代码加锁，使得每一次，只能有一个线程进入同步块，从而保证线程间的安全性。<br/>
<br/>
<br/>
<h5>关键字synchronized可以有多种用法：<h5>

- 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。

- 直接作用与实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。

- 直接作用与静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。